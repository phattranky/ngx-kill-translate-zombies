"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var utils = require("tsutils/typeguard/2.8");
var check_node_1 = require("./shared/check-node");
var Ignore = require("./shared/ignore");
// tslint:disable-next-line:variable-name
exports.Rule = check_node_1.createCheckNodeRule(checkNode, "Using expressions to cause side-effects not allowed.");
function checkNode(node, ctx) {
    if (utils.isExpressionStatement(node)) {
        var children = node.getChildren();
        var isYield = children.every(function (n) { return n.kind === ts.SyntaxKind.YieldExpression; });
        var text = node.getText(node.getSourceFile());
        if (utils.isAwaitExpression(node.expression)) {
            text = node.expression.expression.getText(node.expression.getSourceFile());
        }
        var isIgnored2 = Ignore.isIgnoredPrefix(text, ctx.options.ignorePrefix);
        if (!isYield && !isIgnored2) {
            return { invalidNodes: [check_node_1.createInvalidNode(node, [])] };
        }
    }
    return { invalidNodes: [] };
}
//# sourceMappingURL=noExpressionStatementRule.js.map