"use strict";
/**
 * This file has code that is shared for all the ignore options.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var utils = require("tsutils/typeguard/2.8");
var typeguard_1 = require("./typeguard");
function checkNodeWithIgnore(checkNode) {
    return function (node, ctx) {
        // Skip checking in functions if ignore-local is set
        if (ctx.options.ignoreLocal && typeguard_1.isFunctionLikeDeclaration(node)) {
            // We still need to check the parameters and return type
            var invalidNodes = checkIgnoreLocalFunctionNode(node, ctx, checkNode);
            // Now skip this whole branch
            return { invalidNodes: invalidNodes, skipChildren: true };
        }
        // Skip checking in classes/interfaces if ignore-class/ignore-interface is set
        if ((ctx.options.ignoreClass && utils.isPropertyDeclaration(node)) ||
            (ctx.options.ignoreInterface && utils.isPropertySignature(node))) {
            // Now skip this whole branch
            return { invalidNodes: [], skipChildren: true };
        }
        // Forward to check node
        return checkNode(node, ctx);
    };
}
exports.checkNodeWithIgnore = checkNodeWithIgnore;
function checkIgnoreLocalFunctionNode(functionNode, ctx, checkNode) {
    var myInvalidNodes = [];
    var cb = function (node) {
        // Check the node
        var _a = checkNode(node, ctx), invalidNodes = _a.invalidNodes, skipChildren = _a.skipChildren;
        if (invalidNodes) {
            myInvalidNodes = myInvalidNodes.concat.apply(myInvalidNodes, invalidNodes);
        }
        if (skipChildren) {
            return;
        }
        // Use return because performance hints docs say it optimizes the function using tail-call recursion
        return ts.forEachChild(node, cb);
    };
    // Check either the parameter's explicit type if it has one, or itself for implicit type
    for (var _i = 0, _a = functionNode.parameters.map(function (p) { return (p.type ? p.type : p); }); _i < _a.length; _i++) {
        var n = _a[_i];
        // Check the parameter node itself
        var invalidCheckNodes = checkNode(n, ctx).invalidNodes;
        if (invalidCheckNodes) {
            myInvalidNodes = myInvalidNodes.concat.apply(myInvalidNodes, invalidCheckNodes);
        }
        // Check all children for the paramter node
        ts.forEachChild(n, cb);
    }
    // Check the return type
    var nt = functionNode.type;
    if (nt) {
        // Check the return type node itself
        var invalidCheckNodes = checkNode(nt, ctx).invalidNodes;
        if (invalidCheckNodes) {
            myInvalidNodes = myInvalidNodes.concat.apply(myInvalidNodes, invalidCheckNodes);
        }
        // Check all children for the return type node
        ts.forEachChild(nt, cb);
    }
    return myInvalidNodes;
}
function shouldIgnorePrefix(node, options, sourceFile) {
    // Check ignore-prefix for VariableLikeDeclaration, TypeAliasDeclaration
    if (options.ignorePrefix) {
        if (node &&
            (typeguard_1.isVariableLikeDeclaration(node) || utils.isTypeAliasDeclaration(node))) {
            var variableText = node.name.getText(sourceFile);
            // if (
            //   variableText.substr(0, options.ignorePrefix.length) ===
            //   options.ignorePrefix
            // ) {
            //   return true;
            // }
            if (isIgnoredPrefix(variableText, options.ignorePrefix)) {
                return true;
            }
        }
    }
    return false;
}
exports.shouldIgnorePrefix = shouldIgnorePrefix;
function isIgnoredPrefix(text, ignorePrefix) {
    if (!ignorePrefix) {
        return false;
    }
    if (Array.isArray(ignorePrefix)) {
        if (ignorePrefix.find(function (pfx) { return text.indexOf(pfx) === 0; })) {
            return true;
        }
    }
    else {
        if (text.indexOf(ignorePrefix) === 0) {
            return true;
        }
    }
    return false;
}
exports.isIgnoredPrefix = isIgnoredPrefix;
//# sourceMappingURL=ignore.js.map